<?php

/*
 * This file is part of the symfony package.
 * (c) Leon van der Ree <leon@fun4me.demon.nl>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require_once(dirname(__FILE__).'/../bootstrap/unit.php');

//add propel to include-path
set_include_path($_SERVER['SYMFONY'].'/plugins/sfPropelPlugin/lib/vendor'.PATH_SEPARATOR.get_include_path());


$t = new lime_test(29, new lime_output_color());

//// initialize Propel
//$autoload = sfSimpleAutoload::getInstance(sfToolkit::getTmpDir().DIRECTORY_SEPARATOR.sprintf('sf_autoload_unit_propel_%s.data', md5(__FILE__)));
//$autoload->addDirectory(realpath($_SERVER['SYMFONY'].'/plugins/sfPropelPlugin/lib'));
//$autoload->addDirectory(realpath(dirname(__FILE__).'/model'));
//$autoload->register();

// helper methods
$t->diag('testing helper methods');

// include helper
require_once '../../lib/helper/sfPropelPropertyPathHelper.php';

// include Propel BaseClass
require_once $_SERVER['SYMFONY'].'/plugins/sfPropelPlugin/lib/vendor/propel/Propel.php';
require_once $_SERVER['SYMFONY'].'/plugins/sfPropelPlugin/lib/vendor/propel/util/Criteria.php';
require_once $_SERVER['SYMFONY'].'/plugins/sfPropelPlugin/lib/vendor/propel/om/BaseObject.php';
require_once $_SERVER['SYMFONY'].'/plugins/sfPropelPlugin/lib/vendor/propel/util/BasePeer.php';

require_once $_SERVER['SYMFONY'].'/plugins/sfPropelPlugin/lib/database/sfPropelDatabase.class.php';

// include model
require_once '../mock/MockPropelParent.php';
require_once '../mock/MockPropelParentPeer.php';
require_once '../mock/MockPropelChild.php';
require_once '../mock/MockPropelChildPeer.php';


// setting up the database connection
if (!extension_loaded('SQLite'))
{
  $t->error('SQLite needed to run these tests');
  exit(0);
}

Propel::setDB('propel_mock', new DBSQLite());


$t->diag('resolveBaseClass()  Simply returns the base class in this path');

  $t->is(resolveBaseClass('MockPropelParent.MockPropelChild'), 'MockPropelParent', 'resolveBaseClass resolves first class from objectPath');



$t->diag('resolveClassNameFromObjectPath()  Resolves the last ClassName from the objectPath, with the help of peer::getRelations() generated by the peerBuilder Extension');

  $t->is(resolveClassNameFromObjectPath('MockPropelChild'), 'MockPropelChild', 'resolveClassNameFromObjectPath resolves the latest class from objectPath');
  $t->is(resolveClassNameFromObjectPath('MockPropelChild.MockPropelParent'), 'MockPropelParent', 'resolveClassNameFromObjectPath resolves the latest class from objectPath');
  $t->is(resolveClassNameFromObjectPath('MockPropelChild.MockPropelParent.MockPropelParentRelatedByMockPropelParentId'), 'MockPropelParent', 'resolveClassNameFromObjectPath resolves the latest class from objectPath recursively');

  try
  {
    resolveClassNameFromObjectPath('');
    throw new Exception('should not be here');
  }
  catch (InvalidArgumentException $e) { $t->pass('resolveClassNameFromObjectPath should be called with at least one argument'); }
  catch (Exception $e)                { $t->fail('resolveClassNameFromObjectPath should be called with at least one argument '.$e); }

  try
  {
    resolveClassNameFromObjectPath('MockPropelChild.illegal');
    throw new Exception('should not be here');
  }
  catch (UnexpectedValueException $e) { $t->pass('resolveClassNameFromObjectPath should be called with valid relation-names'); }
  catch (Exception $e)                { $t->fail('resolveClassNameFromObjectPath should be called with valid relation-names'); }



$t->diag('getRelationForRelationPath()  retreives the relation-information of a join');

  $relation = getRelationForRelationPath('MockPropelChild.MockPropelParent');
  $t->is($relation['associateMethod'], 'addMockPropelChild', 'getRelationForRelationPath resolves add Method for the relation');

  try
  {
    $relation = getRelationForRelationPath('MockPropelChild');
    throw new Exception('should not be here');
  }
  catch (InvalidArgumentException $e) { $t->pass('getRelationForRelationPath cannot process only one object-name'); }
  catch (Exception $e)                { $t->fail('getRelationForRelationPath cannot process only one object-name'); }

  try
  {
    $relation = getRelationForRelationPath('MockPropelChild.MockPropelParent.MockPropelParentRelatedByMockPropelParentId');
    throw new Exception('should not be here');
  }
  catch (InvalidArgumentException $e) { $t->pass('getRelationForRelationPath cannot process more than two object-names'); }
  catch (Exception $e)                { $t->fail('getRelationForRelationPath cannot process more than two object-names'); }



$t->diag('checkObjectPath()  Tests if the object path is valid, if not throws an exception');

  try
  {
    checkObjectPath('MockPropelChild.MockPropelParent');
    $t->pass('checkObjectPath OK with valid Path');
  }
  catch (Exception $e) { $t->fail('checkObjectPath OK with valid Path'); }

  try
  {
    checkObjectPath('Invalid');
    $t->fail('checkObjectPath throws an InvalidArgumentException with invalid Class ');
  }
  catch (InvalidArgumentException $e) { $t->pass('checkObjectPath throws an InvalidArgumentException with invalid Class'); }

  try
  {
    checkObjectPath('Invalid.Child.ChildChild');
    $t->fail('checkObjectPath throws an InvalidArgumentException with invalid Path');
  }
  catch (InvalidArgumentException $e) { $t->pass('checkObjectPath throws an InvalidArgumentException: with invalid Path'); }



$t->diag('flattenAllClasses()  Tests if the object path is valid, if not throws an exception');

  $classes = flattenAllClasses('MockPropelChild');
  $expected = array(
    'MockPropelChild' => array(
      'className' => 'MockPropelChild',
      'relatedTo' => array()
    )
  );
  $t->is($classes, $expected, 'flattenAllClasses returns one class "MockPropelChild" without relations');

  $classes = flattenAllClasses('MockPropelChild.MockPropelParent');
  $expected = array (
    'MockPropelChild' =>
    array (
      'className' => 'MockPropelChild',
      'relatedTo' =>
      array (
        'MockPropelParent' =>
        array (
          'relatedClass' => 'MockPropelParent',
          'oneToMany' => false,
          'associateMethod' => 'addMockPropelChild',
          'leftKeys' =>
          array (
            0 => 'mock_propel_child.MOCK_PROPEL_PARENT_ID',
          ),
          'rightKeys' =>
          array (
            0 => 'mock_propel_parent.ID',
          ),
          'joinType' => 'LEFT JOIN',
        ),
      ),
    ),
    'MockPropelChild.MockPropelParent' =>
    array (
      'className' => 'MockPropelParent',
      'relatedTo' => array (),
    ),
  );
  $t->is($classes, $expected, 'flattenAllClasses correctly returns two (recursive) objectPaths for the two objects');



$t->diag('flattenAllClassesArray()  Tests if the object path is valid, if not throws an exception');

  $classes = flattenAllClassesArray(array('MockPropelChild', 'MockPropelChild'));
  $expected = array(
    'MockPropelChild' => array(
      'className' => 'MockPropelChild',
      'relatedTo' => array()
    )
  );
  $t->is($classes, $expected, 'flattenAllClassesArray returns one class "MockPropelChild" without relations, even if same path provided multiple times');


  $classes = flattenAllClassesArray(array('MockPropelParent.MockPropelChilds', 'MockPropelParent.MockPropelParentRelatedByMockPropelParentId'));
  $expected = array (
    'MockPropelParent' =>
    array (
      'className' => 'MockPropelParent',
      'relatedTo' =>
      array (
        'MockPropelChilds' =>
        array (
          'relatedClass' => 'MockPropelChild',
          'oneToMany' => true,
          'associateMethod' => 'setMockPropelParent',
          'leftKeys' =>
          array (
            0 => 'mock_propel_parent.ID',
          ),
          'rightKeys' =>
          array (
            0 => 'mock_propel_child.MOCK_PROPEL_PARENT_ID',
          ),
          'joinType' => 'LEFT JOIN',
        ),
        'MockPropelParentRelatedByMockPropelParentId' =>
        array (
          'relatedClass' => 'MockPropelParent',
          'oneToMany' => false,
          'associateMethod' => 'addMockPropelParentRelatedByMockPropelParentId',
          'leftKeys' =>
          array (
            0 => 'mock_propel_parent.MOCK_PROPEL_PARENT_ID',
          ),
          'rightKeys' =>
          array (
            0 => 'mock_propel_parent.ID',
          ),
          'joinType' => 'LEFT JOIN',
        ),
      ),
    ),
    'MockPropelParent.MockPropelChilds' =>
    array (
      'className' => 'MockPropelChild',
      'relatedTo' =>
      array (
      ),
    ),
    'MockPropelParent.MockPropelParentRelatedByMockPropelParentId' =>
    array (
      'className' => 'MockPropelParent',
      'relatedTo' =>
      array (
      ),
    ),
  );
  $t->is($classes, $expected, 'flattenAllClassesArray returns multiple classes and correct relations');


  try
  {
    $classes = flattenAllClassesArray(array('MockPropelChild.MockPropelParent', 'MockPropelParent.MockPropelChild'));
    throw new Exception('should not be here');
  }
  catch (LogicException $e)  { $t->pass('flattenAllClassesArray with two different bases is not possible'); }
  catch (Exception $e)  { $t->fail('flattenAllClassesArray with two different bases is not possible'); }



$t->diag('getPeerNameForClass()  Simple resolver for Peer class');

  try
  {
    $t->is(getPeerNameForClass('MockPropelChild'), 'MockPropelChildPeer', 'getPeerNameForClass find peer for class "MockPropelChild"');
  }
  catch (Exception $e)  { $t->fail('getPeerNameForClass find peer for class "MockPropelChild"'); }

  try
  {
    getPeerNameForClass('illegal');
    throw new Exception('should not be here');
  }
  catch (InvalidArgumentException $e)  { $t->pass('getPeerNameForClass cannot resolve Peer class for "illegal"'); }
  catch (Exception $e)                 { $t->fail('getPeerNameForClass cannot resolve Peer class for "illegal"'); }



$t->diag('getObjectPathFromProperyPath()  Simple helper that converts a propertyPath to a ObjectPath');

  $t->is(getObjectPathFromProperyPath('MockPropelChild','MockPropelParent.MyCustomGetterParent'), 'MockPropelChild.MockPropelParent', 'getObjectPathFromProperyPath succesfully constructed objectPath');



$t->diag('checkPropertyPath()  Checks the resolved objectPath and if the getter for the property from the final object exist');

  try
  {
    checkPropertyPath('MockPropelChild','Name');
    $t->pass('checkPropertyPath accepts MockPropelChild.Name');
  }
  catch (Exception $e)  { $t->fail('checkPropertyPath accepts MockPropelChild.Name'); }

  try
  {
    checkPropertyPath('MockPropelChild','MockPropelParent.MyCustomGetterParent');
    $t->pass('checkPropertyPath accepts MockPropelChild.MockPropelParent.MyCustomGetterParent');
  }
  catch (Exception $e)  { $t->fail('checkPropertyPath accepts MockPropelChild.MockPropelParent.MyCustomGetterParent'); }

  try
  {
    checkPropertyPath('MockPropelChild','invalid');
    throw new Exception('should not be here');
  }
  catch (LogicException $e)  { $t->pass('checkPropertyPath rejects MockPropelChild.invalid'); }
  catch (Exception $e)       { $t->fail('checkPropertyPath rejects MockPropelChild.invalid'); }



$t->diag('translatePropertyPathToAliasedColumn()  translates a propertyPath to an aliased database selectColumn');

  $t->is(translatePropertyPathToAliasedColumn('MockPropelChild','Name'),                  'MockPropelChild.Name',                  'translatePropertyPathToAliasedColumn  succesfully translated level-1 property path to aliassed columnName');
  $t->is(translatePropertyPathToAliasedColumn('MockPropelChild','MockPropelParent.Name'), 'MockPropelChild_MockPropelParent.Name', 'translatePropertyPathToAliasedColumn  succesfully translated level-2 property path to aliassed columnName');



$t->diag('addJoins()  ');

  $criteria = new Criteria();
  $objectPaths = array('MockPropelChild');
  $withColumns = false;

  $c = addJoins($criteria, $objectPaths, $withColumns);
  $expect = 'Criteria:
SQL (may not be complete): SELECT  FROM mock_propel_child
Params: ';

  $t->is($c->toString(), $expect, 'addJoins generates expected query with objectPaths = array("MockPropelChild")');


  $criteria = new Criteria();
  $objectPaths = array('MockPropelChild.MockPropelParent');

  $c = addJoins($criteria, $objectPaths);
  $expect = 'Criteria:
SQL (may not be complete): SELECT  FROM mock_propel_child MockPropelChild LEFT JOIN mock_propel_parent MockPropelChild_MockPropelParent ON (MockPropelChild.MOCK_PROPEL_PARENT_ID=MockPropelChild_MockPropelParent.ID)
Params: ';

  $t->is($c->toString(), $expect, 'addJoins generates expected query with objectPaths = array("MockPropelChild.MockPropelParent")');



$t->diag('addJoinsAndSelectColumns()  ');

  $criteria = new Criteria();
  $objectPaths = array('MockPropelChild');

  $c = addJoinsAndSelectColumns($criteria, $objectPaths);
  $expect = 'Criteria:
SQL (may not be complete): SELECT MockPropelChild.ID, MockPropelChild.MOCK_PROPEL_PARENT_ID, MockPropelChild.NAME FROM mock_propel_child MockPropelChild
Params: ';

  $t->is($c->toString(), $expect, 'addJoinsAndSelectColumns generates expected query with objectPaths = array("MockPropelChild")');


  $criteria = new Criteria();
  $objectPaths = array('MockPropelChild.MockPropelParent');
  $withColumns = false;

  $c = addJoinsAndSelectColumns($criteria, $objectPaths, $withColumns);
  $expect = 'Criteria:
SQL (may not be complete): SELECT MockPropelChild.ID, MockPropelChild.MOCK_PROPEL_PARENT_ID, MockPropelChild.NAME, MockPropelChild_MockPropelParent.ID, MockPropelChild_MockPropelParent.MOCK_PROPEL_PARENT_ID, MockPropelChild_MockPropelParent.NAME FROM mock_propel_child MockPropelChild LEFT JOIN mock_propel_parent MockPropelChild_MockPropelParent ON (MockPropelChild.MOCK_PROPEL_PARENT_ID=MockPropelChild_MockPropelParent.ID)
Params: ';

  $t->is($c->toString(), $expect, 'addJoinsAndSelectColumns generates expected query with objectPaths = array("MockPropelChild.MockPropelParent")');

// TODO:
/*
hydrate
countAll
*/
